/*-------------------------------------------------------------------------
    Compiler Generator Coco/R,
    Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
    extended by M. Loeberbauer & A. Woess, Univ. of Linz
    with improvements by Pat Terry, Rhodes University
    Swift port by Michael Griebling, 2015-2017

    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2, or (at your option) any
    later version.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

    As an exception, it is allowed to write an extension of Coco/R that is
    used as a plugin in non-free software.

    If not otherwise stated, any source code generated by Coco/R (other than
    Coco/R itself) does not fall under the GNU General Public License.

    NOTE: The code below has been automatically generated from the
    Parser.frame, Scanner.frame and Coco.atg files.  DO NOT EDIT HERE.
-------------------------------------------------------------------------*/

import Foundation
import VirtualMachineLib

public class Parser {
    public let _EOF = 0
    public let _ID = 1
    public let _INTCONS = 2
    public let _FLOATCONS = 3
    public let _CHARCONS = 4
    public let _GENT = 5
    public let _LET = 6
    public let _IN = 7
    public let _FOR = 8
    public let _OTHERWISE = 9
    public let _IFT = 10
    public let _THEN = 11
    public let _ELSE = 12
    public let _DO = 13
    public let _MAIN = 14
    public let _LAMBDA = 15
    public let _READ = 16
    public let _PRINT = 17
    public let _TRUE = 18
    public let _FALSE = 19
    public let _INT = 20
    public let _FLOAT = 21
    public let _CHAR = 22
    public let _BOOL = 23
    public let maxT = 47

    static let _T = true
    static let _x = false
    static let minErrDist = 2
    let minErrDist: Int = Parser.minErrDist

    public var scanner: Scanner
    public var errors: Errors

    public var t: Token             // last recognized token
    public var la: Token            // lookahead token
    var errDist = Parser.minErrDist

    // MARK: Custom properties
    // Code generator
    var codeGenerator: CodeGenerator

    public init(scanner: Scanner, codeGenerator: CodeGenerator) {
        self.scanner = scanner
        self.codeGenerator = codeGenerator

        errors = Errors()
        t = Token()
        la = t
    }

    func SynErr(_ n: Int) {
        if errDist >= minErrDist {
            errors.SynErr(la.line, col: la.col, n: n)
        }
        errDist = 0
    }

    public func SemErr(_ msg: String) {
        if errDist >= minErrDist {
            errors.SemErr(t.line, col: t.col, s: msg)
        }
        errDist = 0
    }

    func Get() {
        while true {
            t = la
            la = scanner.Scan()
            if la.kind <= maxT {
                errDist += 1; break
            }

            la = t
        }
    }

    func Expect(_ n: Int) {
        if la.kind == n {
            Get()
        } else {
            SynErr(n)
        }
    }

    func StartOf(_ s: Int) -> Bool {
        return set(s, la.kind)
    }

    func ExpectWeak(_ n: Int, _ follow: Int) {
        if la.kind == n {
            Get()
        } else {
            SynErr(n)
            while !StartOf(follow) {
                Get()
            }
        }
    }

    func WeakSeparator(_ n: Int, _ syFol: Int, _ repFol: Int) -> Bool {
        var kind = la.kind
        if kind == n {
            Get(); return true
        } else if StartOf(repFol) {
            return false
        } else {
            SynErr(n)
            while !(set(syFol, kind) || set(repFol, kind) || set(0, kind)) {
                Get()
                kind = la.kind
            }
            return StartOf(syFol)
        }
    }

    func Comp() {
        Program()
    }

    func Program() {
        while la.kind == _LET {
            Definition()
        }
        Main()
    }

    // Adds definition to Symbol Table or marks an error.
    func Definition() {
        Expect(_LET)
        Expect(_ID)

        let name = t.val
        if la.kind == 24 /* ":" */ {
            ConstDef(name)
        } else if la.kind == 26 /* "(" */ {
            FuncDef(name)
        } else {
            SynErr(48)
        }
    }

    // Creates a symbol table for its local constants.
    func Main() {
        Expect(_MAIN)
        Expect(25 /* "=" */)

        codeGenerator.newSymbolTable()

        Expect(_DO)
        codeGenerator.pureScope = false
        while la.kind == _LET || la.kind == _PRINT {
            if la.kind == _LET {
                ConstDefInter()
            } else {
                Print()
            }
        }
        codeGenerator.deleteSymbolTable()
    }

    // Receives a symbol name and sets its data type, kind, and child table. If entry is of kind lambda, its parameters
    // will be added to its child table (in another method). Adds the symbolEntry to the symbol table.
    func ConstDef(_ name: String) {
        Expect(24 /* ":" */)
        let type = Type()
        codeGenerator.newSymbol(name: name, type: type, line: t.line, col: t.col)
        codeGenerator.pushName(name, line: t.line, col: t.col)

        Expect(25 /* "=" */)
        codeGenerator.pushOperator(.assgOp)
        if StartOf(1) {
            Expression()
            codeGenerator.generateTwoOperandsExpQuadruple(op: .assgOp, line: t.line, col: t.col)
        } else if la.kind == _READ {
            Get()
            Expect(26 /* "(" */)
            Expect(27 /* ")" */)
            SemanticError.handle(.impureCall, line: t.line, col: t.col)
        } else {
            SynErr(49)
        }
    }

    // Sets the symbolEntry's type and kind. It calls FuncBody(), which will create a symbol table for each pattern
    // matching case.
    func FuncDef(_ name: String) {
        Expect(26 /* "(" */)
        let paramTypes = ParamList()
        Expect(27 /* ")" */)
        Expect(24 /* ":" */)
        let returnType = Type()
        let functionType = DataType.funcType(paramTypes: paramTypes, returnType: returnType)
        codeGenerator.newSymbol(name: name, type: functionType, line: t.line, col: t.col)
        codeGenerator.pushName(name, line: t.line, col: t.col)
        Expect(25 /* "=" */)
        codeGenerator.pushOperator(.assgOp)
        Expect(28 /* "{" */)
        FuncBody(functionType)
        Expect(29 /* "}" */)
        codeGenerator.generateTwoOperandsExpQuadruple(op: .assgOp, line: t.line, col: t.col)
    }

    // Returns the parsed data type.
    @discardableResult
    func Type() -> DataType {
        var res = DataType.noneType
        if StartOf(2) {
            // Simple type.
            res = SimpleType()
        } else if la.kind == 26 /* "(" */ {
            // Function type.
            var paramTypes = [DataType]()
            Get()
            paramTypes.append(Type()) // Reads type from input.
            while la.kind == 30 /* "," */ {
                Get()
                paramTypes.append(Type()) // Reads type from input.
            }
            Expect(27 /* ")" */)
            Expect(24 /* ":" */)
            let returnType = Type()
            res = .funcType(paramTypes: paramTypes, returnType: returnType)
        } else if la.kind == 31 /* "[" */ {
            // List type.
            Get()
            res = .listType(innerType: Type())
            Expect(32 /* "]" */)
        } else {
            res = .errType
            SynErr(50)
        }
        return res
    }

    func Expression() {
        if la.kind == _LAMBDA {
            LambdaExp()
        } else if StartOf(3) {
            SimpleExp()
        } else {
            SynErr(51)
        }
    }

    // Returns an array with the parameter types.
    func ParamList() -> [DataType] {
        var res = [DataType]()
        res.append(Type()) // Reads type from input.
        while la.kind == 30 /* "," */ {
            Get()
            res.append(Type()) // Reads type from input.
        }
        return res
    }

    // Creates a symbol table for each pattern and sets it as the current one.
    func FuncBody(_ funcType: DataType) {
        // Create symbol table for case.
        codeGenerator.newSymbolTable()
        codeGenerator.generateFuncStart(type: funcType, line: t.line, col: t.col)

        Case(funcType)
        // Reset symbol table.
        codeGenerator.deleteSymbolTable()
        while la.kind == _FOR {
            // Create symbol table for case.
            codeGenerator.newSymbolTable()
            Case(funcType)
            // Reset symbol table.
            codeGenerator.deleteSymbolTable()
        }
    }

    // Returns a simple data type.
    func SimpleType() -> DataType {
        var genId: String? = nil
        if la.kind == _INT {
            Get()
        } else if la.kind == _FLOAT {
            Get()
        } else if la.kind == _CHAR {
            Get()
        } else if la.kind == _BOOL {
            Get()
        } else if la.kind == _GENT {
            Get()
            genId = t.val // Generic IDs must have just one letter.
        } else {
            SynErr(52)
        }
        return dataTypeFromSimpleType(t.kind, genericId: genId)
    }

    // Receives the function data type. Used to add local constants to symbol table.
    func Case(_ funcType: DataType) {
        Expect(_FOR)
        // If case statement is used to extract parameter and return types. It is guaranteed that pattern will always
        // have a match.
        if case let DataType.funcType(paramTypes, returnType) = funcType {
            codeGenerator.generateLambdaStart(type: .funcType(paramTypes: paramTypes, returnType: returnType))
            PatternList(paramTypes)
            Expect(25 /* "=" */)
            if la.kind == _LET {
                ConstList()
            }
            Expression()
            codeGenerator.generateLambdaEnd(line: t.line, col: t.col)
        } else {
            SemanticError.handle(.internalError, line: t.line, col: t.col)
        }
    }

    // Receives the parameter types. Matches each pattern with its type.
    func PatternList(_ paramTypes: [DataType]) {
        // TODO: finish pattern matching.
        Pattern(0, paramTypes[0])
        var patCount = 1
        while la.kind == 30 /* "," */ {
            // Validate pattern count.
            if patCount == paramTypes.count {
                SemanticError.handle(
                        .invalidPatternCount(expected: paramTypes.count, received: patCount + 1),
                        line: t.line,
                        col: t.col)
            }
            Get()
            Pattern(patCount, paramTypes[patCount])
            patCount += 1
        }
        // Validate pattern count.
        if patCount != paramTypes.count {
            SemanticError.handle(
                    .invalidPatternCount(expected: paramTypes.count, received: patCount),
                    line: t.line,
                    col: t.col)
        }
    }

    func ConstList() {
        ConstDefInter()
        while la.kind == 30 /* "," */ {
            Get()
            ConstDefInter()
        }
        Expect(_IN)
    }

    // TODO: Finish implementing patterns.
    // Receives a data type and matches the pattern. If pattern is an id, it adds it to the symbol table.
    func Pattern(_ count: Int, _ patternType: DataType) {
        // The name of the parameter the pattern will be matched to.
        let paramName = "\(count)param"
        if la.kind == 42 /* "-" */ || la.kind == _INTCONS || la.kind == _FLOATCONS {
            if la.kind == 42 /* "-" */ {
                Get()
            }
            if la.kind == _INTCONS {
                Get()
            } else if la.kind == _FLOATCONS {
                Get()
            } else {
                SynErr(53)
            }
            SemanticError.handle(.patternNotImplemented, line: t.line, col: t.col)
        } else if la.kind == _CHARCONS {
            Get()
            SemanticError.handle(.patternNotImplemented, line: t.line, col: t.col)
        } else if la.kind == _ID {
            Get()
            let firstId = t.val
            var secondId: String? = nil

            if la.kind == 24 /* ":" */ {
                Get()
                Expect(_ID)
                secondId = t.val
                SemanticError.handle(.patternNotImplemented, line: t.line, col: t.col)
            }

            switch patternType {
            case let .listType(innerType):
                if let secondId = secondId {
                    SemanticError.handle(.patternNotImplemented, line: t.line, col: t.col)
                    // If it is a list type and pattern is "id1:id2", add both ids to symbol table if they are not "_".
                    if firstId != "_" {
                        codeGenerator.newSymbol(name: firstId, type: innerType, line: t.line, col: t.col)
                    }
                    if secondId != "_" {
                        codeGenerator.newSymbol(name: secondId, type: patternType, line: t.line, col: t.col)
                    }
                } else {
                    // If there is only one id, then add it to the symbol table with patternType if it is not "_".
                    if firstId != "_" {
                        codeGenerator.newSymbol(name: firstId, type: patternType, line: t.line, col: t.col)
                        // Assign value from parameter to variable pattern.
                        codeGenerator.pushName(firstId, line: t.line, col: t.col)
                        codeGenerator.pushOperator(.assgOp)
                        codeGenerator.pushName(paramName, line: t.line, col: t.col)
                        codeGenerator.generateTwoOperandsExpQuadruple(op: .assgOp, line: t.line, col: t.col)
                    }
                }
            default:
                if let secondId = secondId {
                    // If patternType != list type and there are two ids, throw an error.
                    // TODO: throw error.
                } else {
                    // Else add entry normally to table.
                    if firstId != "_" {
                        codeGenerator.newSymbol(name: firstId, type: patternType, line: t.line, col: t.col)
                        // Assign value from parameter to variable pattern.
                        codeGenerator.pushName(firstId, line: t.line, col: t.col)
                        codeGenerator.pushOperator(.assgOp)
                        codeGenerator.pushName(paramName, line: t.line, col: t.col)
                        codeGenerator.generateTwoOperandsExpQuadruple(op: .assgOp, line: t.line, col: t.col)
                    }
                }
            }

        } else if la.kind == 31 /* "[" */ {
            Get()
            Expect(32 /* "]" */)
            SemanticError.handle(.patternNotImplemented, line: t.line, col: t.col)
        } else {
            SynErr(53)
        }
    }

    // Creates a symbol entry and sets its name, data type, kind, and child table. If entry is of kind lambda, its
    // parameters will be added to its child table (in another method). Adds the symbolEntry to the symbol table.
    func ConstDefInter() {
        Expect(_LET)
        Expect(_ID)

        let name = t.val
        Expect(24 /* ":" */)

        let type = Type()
        codeGenerator.newSymbol(name: name, type: type, line: t.line, col: t.col)
        codeGenerator.pushName(name, line: t.line, col: t.col)

        Expect(25 /* "=" */)
        codeGenerator.pushOperator(.assgOp)
        if StartOf(1) {
            Expression()
        } else if la.kind == _READ {
            Get()
            Expect(26 /* "(" */)
            Expect(27 /* ")" */)
            codeGenerator.generateRead(type: type, line: t.line, col: t.col)
        } else {
            print(la.kind)
            SynErr(54)
        }
        codeGenerator.generateTwoOperandsExpQuadruple(op: .assgOp, line: t.line, col: t.col)
    }

    // Creates a Symbol Entry for each parameter in the lambda and stores it in the lambda's symbol table or marks
    // error.
    func LambdaExp() {
        Expect(_LAMBDA)
        var paramTypes = [DataType]()
        // Set current symbol table to lambda symbol table.
        codeGenerator.newSymbolTable()
        Expect(26 /* "(" */)
        if la.kind == _ID {
            Get()
            var name = t.val

            Expect(24 /* ":" */)

            var type = Type()
            codeGenerator.newSymbol(name: name, type: type, line: t.line, col: t.col, parameter: true)
            paramTypes.append(type)
            while la.kind == 30 /* "," */ {
                Get()
                Expect(_ID)
                name = t.val
                Expect(24 /* ":" */)

                type = Type()
                codeGenerator.newSymbol(name: name, type: type, line: t.line, col: t.col, parameter: true)
                paramTypes.append(type)
            }
        }
        Expect(27 /* ")" */)
        Expect(24 /* ":" */)
        let returnType = Type()
        Expect(28 /* "{" */)
        codeGenerator.generateLambdaStart(type: .funcType(paramTypes: paramTypes, returnType: returnType))

        Expression()
        Expect(29 /* "}" */)
        codeGenerator.generateLambdaEnd(line: t.line, col: t.col)
        // Reset current symbol table.
        codeGenerator.deleteSymbolTable()
    }

    func SimpleExp() {
        if la.kind == _IFT {
            IfExp()
        } else if StartOf(4) {
            Exp()
        } else {
            SynErr(55)
        }
    }

    func IfExp() {
        Expect(_IFT)
        Exp()
        Expect(_THEN)
        codeGenerator.generateIfStart(line: t.line, col: t.col)
        SimpleExp()
        Expect(_ELSE)
        codeGenerator.generateElseStart()
        SimpleExp()
        codeGenerator.generateIfEnd(line: t.line, col: t.col)
    }

    func Exp() {
        AndExp()
        codeGenerator.generateTwoOperandsExpQuadruple(op: .orOp, line: t.line, col: t.col)
        while la.kind == 33 /* "|" */ {
            Get()
            codeGenerator.pushOperator(LangOperator(rawValue: t.val)!)
            AndExp()
            codeGenerator.generateTwoOperandsExpQuadruple(op: .orOp, line: t.line, col: t.col)
        }
    }

    func AndExp() {
        LogicalExp()
        codeGenerator.generateTwoOperandsExpQuadruple(op: .andOp, line: t.line, col: t.col)
        while la.kind == 34 /* "&" */ {
            Get()
            codeGenerator.pushOperator(LangOperator(rawValue: t.val)!)
            LogicalExp()
            codeGenerator.generateTwoOperandsExpQuadruple(op: .andOp, line: t.line, col: t.col)
        }
    }

    func LogicalExp() {
        MathExp()
        codeGenerator.generateTwoOperandsExpQuadruple(op: .eqOp, line: t.line, col: t.col)
        while StartOf(5) {
            switch la.kind {
            case 35 /* "==" */:
                Get()
            case 36 /* "!=" */:
                Get()
            case 37 /* "<" */:
                Get()
            case 38 /* "<=" */:
                Get()
            case 39 /* ">" */:
                Get()
            case 40 /* ">=" */:
                Get()
            default:
                break
            }
            codeGenerator.pushOperator(LangOperator(rawValue: t.val)!)
            MathExp()
            codeGenerator.generateTwoOperandsExpQuadruple(op: .eqOp, line: t.line, col: t.col)
        }
    }

    func MathExp() {
        Term()
        codeGenerator.generateTwoOperandsExpQuadruple(op: .plusOp, line: t.line, col: t.col)
        while la.kind == 41 /* "+" */ || la.kind == 42 /* "-" */ {
            if la.kind == 41 /* "+" */ {
                Get()
            } else {
                Get()
            }
            codeGenerator.pushOperator(LangOperator(rawValue: t.val)!)
            Term()
            codeGenerator.generateTwoOperandsExpQuadruple(op: .plusOp, line: t.line, col: t.col)
        }
    }

    func Term() {
        ListExp()
        codeGenerator.generateTwoOperandsExpQuadruple(op: .multOp, line: t.line, col: t.col)
        while la.kind == 43 /* "*" */ || la.kind == 44 /* "/" */ {
            if la.kind == 43 /* "*" */ {
                Get()
            } else {
                Get()
            }
            codeGenerator.pushOperator(LangOperator(rawValue: t.val)!)
            ListExp()
            codeGenerator.generateTwoOperandsExpQuadruple(op: .multOp, line: t.line, col: t.col)
        }
    }

    func ListExp() {
        ConsExp()
        codeGenerator.generateListExpQuadruple(op: .appendOp, line: t.line, col: t.col)
        while la.kind == 45 /* "++" */ {
            Get()

            codeGenerator.pushOperator(LangOperator(rawValue: t.val)!)
            ConsExp()
            codeGenerator.generateListExpQuadruple(op: .appendOp, line: t.line, col: t.col)
        }
    }

    func ConsExp() {
        Factor()
        while la.kind == 24 /* ":" */ {
            Get()

            codeGenerator.pushOperator(LangOperator(rawValue: t.val)!)
            Factor()
        }
        codeGenerator.generateListExpRightQuadruple(op: .consOp, line: t.line, col: t.col)
    }

    func Factor() {
        if la.kind == 41 /* "+" */ || la.kind == 42 /* "-" */ || la.kind == 46 /* "!" */ {
            if la.kind == 41 /* "+" */ {
                Get()
            } else if la.kind == 42 /* "-" */ {
                Get()
            } else {
                Get()
            }
            let op: LangOperator
            switch t.val {
            case "+":
                op = .posOp
            case "-":
                op = .negOp
            default:
                op = .notOp
            }
            codeGenerator.pushOperator(op)
        }
        switch la.kind {
        case _INTCONS:
            Get()
            codeGenerator.pushLiteral(t.val, type: .intType)
        case _FLOATCONS:
            Get()
            codeGenerator.pushLiteral(t.val, type: .floatType)
        case _CHARCONS:
            Get()
            codeGenerator.pushLiteral(t.val, type: .charType)
        case _TRUE:
            Get()
            codeGenerator.pushLiteral(t.val, type: .boolType)
        case _FALSE:
            Get()
            codeGenerator.pushLiteral(t.val, type: .boolType)
        case _ID:
            Get()
            let name = t.val
            codeGenerator.pushName(name, line: t.line, col: t.col)
            if la.kind == 26 /* "(" */ {
                Get()
                var argCount = 0
                codeGenerator.generateFuncCallStart(line: t.line, col: t.col)
                codeGenerator.pushOperator(.placeholderOp) // False stack bottom.
                if StartOf(1) {
                    Expression()
                    codeGenerator.generateArgument(atPosition: argCount, line: t.line, col: t.col)
                    argCount += 1
                    while la.kind == 30 /* "," */ {
                        Get()
                        Expression()
                        codeGenerator.generateArgument(atPosition: argCount, line: t.line, col: t.col)
                        argCount += 1
                    }
                }
                Expect(27 /* ")" */)
                codeGenerator.generateFuncCallEnd(argCount: argCount, line: t.line, col: t.col)
                codeGenerator.popOperator() // Pop false stack bottom.
            }
        case 31 /* "[" */:
            List()
        case 26 /* "(" */:
            Get()
            codeGenerator.pushOperator(.placeholderOp) // False bottom of operator stack.
            SimpleExp()
            Expect(27 /* ")" */)
            codeGenerator.popOperator() // Remove false bottom.
        default:
            SynErr(56)
        }
        codeGenerator.generateOneOperandExpQuadruple(op: .posOp, line: t.line, col: t.col)
    }

    func List() {
        Expect(31 /* "[" */)
        if StartOf(1) {
            codeGenerator.pushOperator(.placeholderOp)
            Expression()
            codeGenerator.popOperator()
            codeGenerator.pushOperator(.consOp)
            while la.kind == 30 /* "," */ {
                Get()
                codeGenerator.pushOperator(.placeholderOp)
                Expression()
                codeGenerator.popOperator()
                codeGenerator.pushOperator(.consOp)
            }
        }
        codeGenerator.pushList()
        Expect(32 /* "]" */)
    }

    // Generates quadruples for print statement.
    func Print() {
        Expect(_PRINT)
        Expect(26 /* "(" */)
        SimpleExp()
        Expect(27 /* ")" */)
        codeGenerator.generatePrint()
    }


    public func Parse() {
        la = Token()
        la.val = ""
        Get()
        Comp()
        Expect(_EOF)
        codeGenerator.generateProgramEnd()
    }

    // Saves the generated code to the specified path.
    public func save(toPath path: String) {
        codeGenerator.save(toPath: path)
    }

    func set(_ x: Int, _ y: Int) -> Bool {
        return Parser._set[x][y]
    }

    static let _set: [[Bool]] = [
        [_T, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x],
        [_x, _T, _T, _T, _T, _x, _x, _x, _x, _x, _T, _x, _x, _x, _x, _T, _x, _x, _T, _T, _x, _x, _x, _x, _x, _x, _T, _x, _x, _x, _x, _T, _x, _x, _x, _x, _x, _x, _x, _x, _x, _T, _T, _x, _x, _x, _T, _x, _x],
        [_x, _x, _x, _x, _x, _T, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _T, _T, _T, _T, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x],
        [_x, _T, _T, _T, _T, _x, _x, _x, _x, _x, _T, _x, _x, _x, _x, _x, _x, _x, _T, _T, _x, _x, _x, _x, _x, _x, _T, _x, _x, _x, _x, _T, _x, _x, _x, _x, _x, _x, _x, _x, _x, _T, _T, _x, _x, _x, _T, _x, _x],
        [_x, _T, _T, _T, _T, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _T, _T, _x, _x, _x, _x, _x, _x, _T, _x, _x, _x, _x, _T, _x, _x, _x, _x, _x, _x, _x, _x, _x, _T, _T, _x, _x, _x, _T, _x, _x],
        [_x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _x, _T, _T, _T, _T, _T, _T, _x, _x, _x, _x, _x, _x, _x, _x]

    ]
} // end Parser


public class Errors {
    public var count = 0                                 // number of errors detected
    private let errorStream = stderr              // error messages go to this stream
    public var errMsgFormat = "-- line %i col %i: %@"    // 0=line, 1=column, 2=text

    func Write(_ s: String) {
        fputs(s, errorStream)
    }

    func WriteLine(_ format: String, line: Int, col: Int, s: String) {
        let str = "-- line \(line) col \(col): \(s)"
        WriteLine(str)
    }

    func WriteLine(_ s: String) {
        Write(s + "\n")
    }

    public func SynErr(_ line: Int, col: Int, n: Int) {
        var s: String
        switch n {
        case 0: s = "EOF expected"
        case 1: s = "ID expected"
        case 2: s = "INTCONS expected"
        case 3: s = "FLOATCONS expected"
        case 4: s = "CHARCONS expected"
        case 5: s = "GENT expected"
        case 6: s = "LET expected"
        case 7: s = "IN expected"
        case 8: s = "FOR expected"
        case 9: s = "OTHERWISE expected"
        case 10: s = "IFT expected"
        case 11: s = "THEN expected"
        case 12: s = "ELSE expected"
        case 13: s = "DO expected"
        case 14: s = "MAIN expected"
        case 15: s = "LAMBDA expected"
        case 16: s = "READ expected"
        case 17: s = "PRINT expected"
        case 18: s = "TRUE expected"
        case 19: s = "FALSE expected"
        case 20: s = "INT expected"
        case 21: s = "FLOAT expected"
        case 22: s = "CHAR expected"
        case 23: s = "BOOL expected"
        case 24: s = "\":\" expected"
        case 25: s = "\"=\" expected"
        case 26: s = "\"(\" expected"
        case 27: s = "\")\" expected"
        case 28: s = "\"{\" expected"
        case 29: s = "\"}\" expected"
        case 30: s = "\",\" expected"
        case 31: s = "\"[\" expected"
        case 32: s = "\"]\" expected"
        case 33: s = "\"|\" expected"
        case 34: s = "\"&\" expected"
        case 35: s = "\"==\" expected"
        case 36: s = "\"!=\" expected"
        case 37: s = "\"<\" expected"
        case 38: s = "\"<=\" expected"
        case 39: s = "\">\" expected"
        case 40: s = "\">=\" expected"
        case 41: s = "\"+\" expected"
        case 42: s = "\"-\" expected"
        case 43: s = "\"*\" expected"
        case 44: s = "\"/\" expected"
        case 45: s = "\"++\" expected"
        case 46: s = "\"!\" expected"
        case 47: s = "??? expected"
        case 48: s = "invalid Definition"
        case 49: s = "invalid ConstDef"
        case 50: s = "invalid Type"
        case 51: s = "invalid Expression"
        case 52: s = "invalid SimpleType"
        case 53: s = "invalid Pattern"
        case 54: s = "invalid ConstDefInter"
        case 55: s = "invalid SimpleExp"
        case 56: s = "invalid Factor"

        default: s = "error \(n)"
        }
        WriteLine(errMsgFormat, line: line, col: col, s: s)
        count += 1
    }

    public func SemErr(_ line: Int, col: Int, s: String) {
        WriteLine(errMsgFormat, line: line, col: col, s: s);
        count += 1
    }

    public func SemErr(_ s: String) {
        WriteLine(s)
        count += 1
    }

    public func Warning(_ line: Int, col: Int, s: String) {
        WriteLine(errMsgFormat, line: line, col: col, s: s)
    }

    public func Warning(_ s: String) {
        WriteLine(s)
    }
} // Errors

// MARK: Added extension.
// Utility functions
extension Parser {
    // Convenience function to convert simple type constants to DataTypes.
    func dataTypeFromSimpleType(_ simpleT: Int, genericId: String? = nil) -> DataType {
        switch simpleT {
        case _INT:
            return .intType
        case _FLOAT:
            return .floatType
        case _BOOL:
            return .boolType
        case _CHAR:
            return .charType
        case _GENT:
            return .genType(identifier: genericId!) // If type is generic, then it must always have an ID.
        default:
            return .noneType
        }
    }
}
